# Graph-Based Architecture & BM25 Search for Claude Code Agent Observability

**Date**: 2025-01-14  
**Generated by**: Claude Code Assistant  
**Purpose**: Define graph relationships and search architecture for multi-agent observability

## Overview

This document outlines how we'll use ArangoDB's graph capabilities and BM25 search to create a powerful observability system that tracks relationships between agent actions, tools, and outcomes.

## Graph Architecture

### 1. Node Types (Vertex Collections)

#### `agent_sessions`
Represents a Claude Code agent session
```javascript
{
  _key: "session_abc123",
  session_id: "abc123",
  agent_name: "claude-code-main",
  start_time: "2025-01-14T10:00:00Z",
  end_time: "2025-01-14T10:30:00Z",
  source_app: "cc-executor",
  metadata: {
    user: "graham",
    project: "logger_agent",
    purpose: "implement dashboard"
  }
}
```

#### `tool_executions`
Represents individual tool uses
```javascript
{
  _key: "tool_exec_xyz789",
  tool_name: "Bash",
  command: "uv run pytest",
  start_time: "2025-01-14T10:05:00Z",
  end_time: "2025-01-14T10:05:30Z",
  exit_code: 0,
  output_preview: "All tests passed...",
  session_id: "abc123"
}
```

#### `code_artifacts`
Files created or modified by agents
```javascript
{
  _key: "artifact_file123",
  file_path: "src/api/dashboard_server.py",
  operation: "created",
  language: "python",
  size: 4532,
  hash: "sha256:abcdef...",
  session_id: "abc123"
}
```

#### `agent_insights`
Learnings and observations made by agents
```javascript
{
  _key: "insight_learn456",
  content: "Using asyncio.to_thread is essential for python-arango compatibility",
  confidence: 0.9,
  context: {
    problem: "aioarango import errors",
    solution: "switched to python-arango with asyncio.to_thread"
  },
  tags: ["python", "async", "arangodb"]
}
```

#### `errors_and_failures`
Errors encountered during execution
```javascript
{
  _key: "error_fail789",
  error_type: "ModuleNotFoundError",
  message: "No module named 'aioarango'",
  stack_trace: "...",
  file_context: "src/arango_log_sink.py:23",
  resolution: "installed python-arango instead"
}
```

### 2. Edge Collections (Relationships)

#### `agent_flow` (Execution Flow)
Tracks the sequence of actions within a session
```javascript
{
  _from: "tool_executions/tool_exec_1",
  _to: "tool_executions/tool_exec_2",
  relationship: "FOLLOWED_BY",
  time_delta_seconds: 5,
  causal_link: true,
  metadata: {
    reason: "test failure led to code fix"
  }
}
```

#### `tool_dependencies`
Shows which tools depend on outputs from other tools
```javascript
{
  _from: "tool_executions/bash_uv_add",
  _to: "tool_executions/python_test",
  relationship: "ENABLES",
  dependency_type: "package_installation",
  package: "python-arango"
}
```

#### `error_causality`
Links errors to their causes and resolutions
```javascript
{
  _from: "errors_and_failures/error_1",
  _to: "tool_executions/fix_attempt_1",
  relationship: "TRIGGERED",
  resolution_status: "success",
  time_to_fix_seconds: 120
}
```

#### `artifact_lineage`
Tracks file creation and modification chains
```javascript
{
  _from: "code_artifacts/original_file",
  _to: "code_artifacts/modified_file",
  relationship: "MODIFIED_TO",
  changes: {
    lines_added: 45,
    lines_removed: 12,
    refactoring_type: "asyncio_conversion"
  }
}
```

#### `insight_applications`
Links insights to where they were applied
```javascript
{
  _from: "agent_insights/insight_1",
  _to: "tool_executions/implementation_1",
  relationship: "APPLIED_IN",
  effectiveness: 0.95
}
```

### 3. Graph Creation in ArangoDB

```python
# src/arangodb/core/graph/agent_graph_builder.py

async def initialize_agent_graph(db):
    """Create the multi-agent observability graph structure."""
    
    # Create vertex collections
    vertex_collections = [
        "agent_sessions",
        "tool_executions", 
        "code_artifacts",
        "agent_insights",
        "errors_and_failures",
        "log_events"  # Existing collection
    ]
    
    for collection in vertex_collections:
        if not db.has_collection(collection):
            db.create_collection(collection)
    
    # Create edge collections with definitions
    edge_definitions = [
        {
            "edge_collection": "agent_flow",
            "from_vertex_collections": ["tool_executions", "agent_sessions"],
            "to_vertex_collections": ["tool_executions", "errors_and_failures", "code_artifacts"]
        },
        {
            "edge_collection": "tool_dependencies",
            "from_vertex_collections": ["tool_executions"],
            "to_vertex_collections": ["tool_executions", "code_artifacts"]
        },
        {
            "edge_collection": "error_causality",
            "from_vertex_collections": ["errors_and_failures", "tool_executions"],
            "to_vertex_collections": ["tool_executions", "agent_insights", "code_artifacts"]
        },
        {
            "edge_collection": "artifact_lineage",
            "from_vertex_collections": ["code_artifacts"],
            "to_vertex_collections": ["code_artifacts"]
        },
        {
            "edge_collection": "insight_applications",
            "from_vertex_collections": ["agent_insights"],
            "to_vertex_collections": ["tool_executions", "code_artifacts"]
        }
    ]
    
    # Create or update graph
    graph_name = "claude_agent_observatory"
    if not db.has_graph(graph_name):
        db.create_graph(
            graph_name,
            edge_definitions=edge_definitions
        )
```

## BM25 Full-Text Search Architecture

### 1. Enhanced ArangoSearch Views

```javascript
// Create comprehensive search view for all agent activity
db.create_arangosearch_view(
  "agent_activity_search",
  {
    "links": {
      "log_events": {
        "analyzers": ["text_en", "identity"],
        "fields": {
          "message": {
            "analyzers": ["text_en"]
          },
          "extra_data.payload.tool_input.command": {
            "analyzers": ["text_en", "identity"]  // For bash commands
          },
          "extra_data.summary": {
            "analyzers": ["text_en"]
          }
        },
        "includeAllFields": true,
        "storeValues": "id"
      },
      "tool_executions": {
        "analyzers": ["text_en", "identity"],
        "fields": {
          "command": {
            "analyzers": ["text_en", "identity"]
          },
          "output_preview": {
            "analyzers": ["text_en"]
          },
          "tool_name": {
            "analyzers": ["identity"]
          }
        }
      },
      "agent_insights": {
        "analyzers": ["text_en"],
        "fields": {
          "content": {
            "analyzers": ["text_en"]
          },
          "context.problem": {
            "analyzers": ["text_en"]
          },
          "context.solution": {
            "analyzers": ["text_en"]
          },
          "tags": {
            "analyzers": ["identity"]
          }
        }
      },
      "errors_and_failures": {
        "analyzers": ["text_en", "identity"],
        "fields": {
          "message": {
            "analyzers": ["text_en"]
          },
          "error_type": {
            "analyzers": ["identity"]
          },
          "resolution": {
            "analyzers": ["text_en"]
          }
        }
      },
      "code_artifacts": {
        "analyzers": ["identity"],
        "fields": {
          "file_path": {
            "analyzers": ["identity"]
          },
          "language": {
            "analyzers": ["identity"]
          }
        }
      }
    }
  }
)
```

### 2. BM25 Search Queries

```python
# src/arangodb/core/search/agent_search.py

async def search_agent_activity(query: str, filters: dict = None, limit: int = 50):
    """
    Search across all agent activity using BM25 scoring.
    """
    aql = """
    FOR doc IN agent_activity_search
    SEARCH ANALYZER(
        TOKENS(@query, 'text_en') ALL IN doc.message OR
        TOKENS(@query, 'text_en') ALL IN doc.command OR
        TOKENS(@query, 'text_en') ALL IN doc.content OR
        TOKENS(@query, 'text_en') ALL IN doc.output_preview OR
        PHRASE(doc.file_path, @query, 'identity')
    )
    %s
    SORT BM25(doc) DESC
    LIMIT @limit
    RETURN {
        doc: doc,
        score: BM25(doc),
        type: REGEX_TEST(doc._id, '^log_events/') ? 'log' :
              REGEX_TEST(doc._id, '^tool_executions/') ? 'tool' :
              REGEX_TEST(doc._id, '^agent_insights/') ? 'insight' :
              REGEX_TEST(doc._id, '^errors_and_failures/') ? 'error' :
              REGEX_TEST(doc._id, '^code_artifacts/') ? 'artifact' : 'unknown'
    }
    """ % (_build_filter_clause(filters))
    
    return await db.aql.execute(aql, bind_vars={
        "query": query,
        "limit": limit,
        **filters
    })

async def search_error_patterns(error_type: str = None, time_range: dict = None):
    """
    Search for error patterns and their resolutions.
    """
    aql = """
    FOR error IN errors_and_failures
    %s
    LET resolutions = (
        FOR v, e IN 1..3 OUTBOUND error error_causality
        FILTER e.resolution_status == 'success'
        RETURN {
            resolution: v,
            edge: e,
            type: REGEX_TEST(v._id, '^tool_executions/') ? 'tool_fix' :
                  REGEX_TEST(v._id, '^agent_insights/') ? 'insight' : 'other'
        }
    )
    SORT error.timestamp DESC
    RETURN {
        error: error,
        resolutions: resolutions,
        resolution_count: LENGTH(resolutions),
        avg_time_to_fix: AVG(FOR r IN resolutions RETURN r.edge.time_to_fix_seconds)
    }
    """ % (_build_error_filters(error_type, time_range))
    
    return await db.aql.execute(aql, bind_vars={
        "error_type": error_type,
        **_time_range_vars(time_range)
    })
```

### 3. Graph Traversal Queries

```python
async def get_execution_flow(session_id: str):
    """
    Get the complete execution flow for a session.
    """
    aql = """
    LET session = FIRST(
        FOR s IN agent_sessions
        FILTER s.session_id == @session_id
        RETURN s
    )
    
    FOR v, e, p IN 1..100 OUTBOUND session agent_flow
    OPTIONS {uniqueVertices: 'path'}
    RETURN {
        path_length: LENGTH(p.edges),
        vertex: v,
        edge: e,
        path: p,
        is_error: REGEX_TEST(v._id, '^errors_and_failures/'),
        is_insight: REGEX_TEST(v._id, '^agent_insights/')
    }
    """
    
    return await db.aql.execute(aql, bind_vars={"session_id": session_id})

async def find_similar_errors(error_id: str, similarity_threshold: float = 0.8):
    """
    Find similar errors using graph patterns and text similarity.
    """
    aql = """
    LET target_error = DOCUMENT(@error_id)
    
    FOR error IN errors_and_failures
    FILTER error._id != @error_id
    LET similarity = (
        // Text similarity using BM25
        FOR doc IN agent_activity_search
        SEARCH doc._id == error._id AND 
               ANALYZER(TOKENS(target_error.message, 'text_en') ALL IN doc.message)
        RETURN BM25(doc)
    )[0]
    
    FILTER similarity > @threshold
    
    // Find resolution patterns
    LET resolution_pattern = (
        FOR v, e IN 1..2 OUTBOUND error error_causality
        RETURN {
            type: e.relationship,
            resolution: v.tool_name OR v.content,
            success: e.resolution_status == 'success'
        }
    )
    
    SORT similarity DESC
    LIMIT 10
    RETURN {
        error: error,
        similarity: similarity,
        resolution_pattern: resolution_pattern,
        has_successful_resolution: 'success' IN resolution_pattern[*].success
    }
    """
    
    return await db.aql.execute(aql, bind_vars={
        "error_id": error_id,
        "threshold": similarity_threshold
    })
```

## Dashboard Integration Features

### 1. Graph Visualization Component

```vue
<!-- dashboard/src/components/ExecutionGraph.vue -->
<template>
  <div class="execution-graph">
    <svg ref="graphContainer" :width="width" :height="height">
      <!-- D3.js or vis.js graph visualization -->
    </svg>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import * as d3 from 'd3'

const props = defineProps<{
  sessionId: string
}>()

onMounted(async () => {
  // Fetch execution flow from API
  const flow = await fetch(`/api/sessions/${props.sessionId}/flow`)
  const data = await flow.json()
  
  // Render interactive graph
  renderExecutionGraph(data)
})

function renderExecutionGraph(data) {
  // D3.js force-directed graph
  // Color nodes by type (tool, error, insight, artifact)
  // Show edges with labels (FOLLOWED_BY, TRIGGERED, etc.)
  // Interactive: click to expand details
}
</script>
```

### 2. BM25 Search Interface

```vue
<!-- dashboard/src/components/SmartSearch.vue -->
<template>
  <div class="smart-search">
    <input 
      v-model="searchQuery"
      @input="performSearch"
      placeholder="Search across all agent activity..."
      class="search-input"
    />
    
    <div class="search-filters">
      <label>
        <input type="checkbox" v-model="filters.includeErrors" />
        Include Errors
      </label>
      <label>
        <input type="checkbox" v-model="filters.includeInsights" />
        Include Insights
      </label>
      <select v-model="filters.timeRange">
        <option value="1h">Last Hour</option>
        <option value="24h">Last 24 Hours</option>
        <option value="7d">Last 7 Days</option>
      </select>
    </div>
    
    <div class="search-results">
      <div 
        v-for="result in results" 
        :key="result.doc._id"
        class="result-item"
        :class="`result-type-${result.type}`"
      >
        <span class="relevance-score">{{ (result.score * 100).toFixed(1) }}%</span>
        <span class="result-type">{{ result.type }}</span>
        <div class="result-content">
          <highlight :text="getResultText(result)" :query="searchQuery" />
        </div>
        
        <!-- Graph context -->
        <div v-if="result.graph_context" class="graph-context">
          <span>Related to: {{ result.graph_context.related_count }} other items</span>
        </div>
      </div>
    </div>
  </div>
</template>
```

### 3. Error Pattern Analysis

```vue
<!-- dashboard/src/components/ErrorPatterns.vue -->
<template>
  <div class="error-patterns">
    <h3>Common Error Patterns</h3>
    
    <div v-for="pattern in errorPatterns" :key="pattern.error_type" class="pattern-card">
      <h4>{{ pattern.error_type }}</h4>
      <div class="pattern-stats">
        <span>Occurrences: {{ pattern.count }}</span>
        <span>Avg Fix Time: {{ formatDuration(pattern.avg_fix_time) }}</span>
        <span>Success Rate: {{ pattern.success_rate }}%</span>
      </div>
      
      <div class="common-resolutions">
        <h5>Common Resolutions:</h5>
        <ul>
          <li v-for="res in pattern.resolutions" :key="res.id">
            {{ res.description }} ({{ res.success_count }} times)
          </li>
        </ul>
      </div>
      
      <button @click="showSimilarErrors(pattern.error_type)">
        Find Similar Errors
      </button>
    </div>
  </div>
</template>
```

## Benefits of Graph + BM25 Architecture

1. **Relationship Discovery**: Automatically discover patterns in agent behavior
2. **Error Resolution Mining**: Learn from past fixes to suggest solutions
3. **Execution Flow Analysis**: Visualize complex multi-step operations
4. **Semantic Search**: Find relevant information across all agent activities
5. **Impact Analysis**: Trace which files/tools are affected by changes
6. **Performance Insights**: Identify bottlenecks in execution chains
7. **Knowledge Extraction**: Build a knowledge base from agent insights

## Implementation Priority

1. **Phase 1**: Core graph structure and basic relationships
2. **Phase 2**: BM25 search across all collections
3. **Phase 3**: Dashboard visualization components
4. **Phase 4**: Advanced analytics and pattern mining
5. **Phase 5**: ML-based recommendation system

This architecture leverages ArangoDB's strengths to provide deep insights into Claude Code agent behavior and performance.