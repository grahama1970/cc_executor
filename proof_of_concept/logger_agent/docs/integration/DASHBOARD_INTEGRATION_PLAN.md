# Dashboard Integration Plan: Multi-Agent Observability for Logger Agent

**Date**: 2025-01-14  
**Generated by**: Claude Code Assistant  
**Purpose**: Integrate the multi-agent observability dashboard into logger_agent using ArangoDB

## Executive Summary

We will integrate the claude-code-hooks-multi-agent-observability dashboard into the logger_agent project, replacing SQLite with ArangoDB as the backend. This will provide a real-time web interface for monitoring and visualizing agent logs and execution traces.

## Architecture Overview

### Current State (claude-code-hooks-observability)
```
Claude Agents → Hook Scripts → HTTP POST → Bun Server → SQLite → WebSocket → Vue Client
```

### Target State (logger_agent integration)
```
Claude Agents → Hook Scripts → HTTP POST → Logger Agent API → ArangoDB → WebSocket → Vue Client
```

## Key Components to Integrate

### 1. Frontend (Vue 3 Client)
- **Location**: `apps/client/` from observability repo
- **Key Features to Preserve**:
  - Real-time WebSocket updates
  - Event timeline with filtering
  - Live pulse chart visualization
  - Session and app color coding
  - Theme management
  - Chat transcript viewer

### 2. Backend API
- **Replace**: Bun SQLite server
- **With**: Python FastAPI/Starlette server using ArangoDB
- **Key Endpoints**:
  - `POST /events` - Receive events from agents
  - `GET /events/recent` - Paginated event retrieval
  - `GET /events/filter-options` - Available filter values
  - `WS /stream` - Real-time event broadcasting

### 3. Database Schema Mapping

#### SQLite → ArangoDB Collection Mapping

**events table → log_events collection**:
```javascript
// SQLite schema
{
  id: INTEGER PRIMARY KEY,
  source_app: TEXT,
  session_id: TEXT,
  hook_event_type: TEXT,
  payload: TEXT (JSON),
  chat: TEXT (JSON),
  summary: TEXT,
  timestamp: INTEGER
}

// ArangoDB document (existing log_events collection)
{
  _key: "auto-generated",
  timestamp: "ISO-8601",
  level: "INFO", // Add for hook events
  message: "Hook event: {hook_event_type}",
  execution_id: "{session_id}",
  script_name: "{source_app}",
  function_name: "claude_hook",
  file_path: ".claude/hooks/",
  line_number: 0,
  extra_data: {
    hook_event_type: "PreToolUse",
    payload: { /* original payload */ },
    chat: [ /* chat transcript */ ],
    summary: "AI-generated summary"
  },
  tags: ["claude-hook", "{hook_event_type}"]
}
```

## Implementation Steps

### Phase 1: Backend API Development

1. **Create FastAPI Server** (`src/api/dashboard_server.py`):
```python
from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware
import asyncio
from typing import List, Dict, Any
from datetime import datetime

app = FastAPI()

# Enable CORS for Vue client
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    
    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
    
    async def broadcast(self, message: dict):
        for connection in self.active_connections:
            try:
                await connection.send_json(message)
            except:
                pass

manager = ConnectionManager()

@app.post("/events")
async def receive_event(event: Dict[str, Any]):
    """Receive events from Claude Code hooks."""
    # Transform hook event to log_events format
    log_doc = {
        "timestamp": datetime.utcnow().isoformat(),
        "level": "INFO",
        "message": f"Hook event: {event['hook_event_type']}",
        "execution_id": event["session_id"],
        "script_name": event["source_app"],
        "function_name": "claude_hook",
        "file_path": ".claude/hooks/",
        "line_number": 0,
        "extra_data": {
            "hook_event_type": event["hook_event_type"],
            "payload": event["payload"],
            "chat": event.get("chat"),
            "summary": event.get("summary")
        },
        "tags": ["claude-hook", event["hook_event_type"]]
    }
    
    # Store in ArangoDB
    manager = await get_log_manager()
    await manager.db.collection("log_events").insert(log_doc)
    
    # Broadcast to WebSocket clients
    await manager.broadcast({
        "type": "new_event",
        "event": transform_for_frontend(log_doc)
    })
    
    return {"status": "success"}

@app.get("/events/recent")
async def get_recent_events(
    limit: int = 100,
    source_app: str = None,
    session_id: str = None,
    hook_event_type: str = None
):
    """Get recent events with filtering."""
    # Build AQL query
    filters = []
    bind_vars = {"limit": limit}
    
    if source_app:
        filters.append("doc.script_name == @source_app")
        bind_vars["source_app"] = source_app
    
    if session_id:
        filters.append("doc.execution_id == @session_id") 
        bind_vars["session_id"] = session_id
    
    if hook_event_type:
        filters.append("doc.extra_data.hook_event_type == @hook_event_type")
        bind_vars["hook_event_type"] = hook_event_type
    
    # Always filter for claude-hook tagged events
    filters.append("'claude-hook' IN doc.tags")
    
    where_clause = " AND ".join(filters)
    
    aql = f"""
    FOR doc IN log_events
    FILTER {where_clause}
    SORT doc.timestamp DESC
    LIMIT @limit
    RETURN doc
    """
    
    manager = await get_log_manager()
    events = await manager.query_logs(aql, bind_vars)
    
    return [transform_for_frontend(event) for event in events]

@app.websocket("/stream")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            # Keep connection alive
            await asyncio.sleep(1)
    except:
        manager.disconnect(websocket)
```

### Phase 2: Frontend Integration

1. **Copy Vue Client**:
```bash
cp -r /path/to/observability/apps/client logger_agent/dashboard/
```

2. **Update Frontend Configuration** (`dashboard/src/utils/api.ts`):
```typescript
// Change API endpoints to use new backend
const API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:8000'
const WS_URL = import.meta.env.VITE_WS_URL || 'ws://localhost:8000/stream'
```

3. **Update Event Type Mapping**:
```typescript
// Map ArangoDB log format to frontend format
export function transformEvent(dbEvent: any): HookEvent {
  return {
    id: dbEvent._key,
    source_app: dbEvent.script_name,
    session_id: dbEvent.execution_id,
    hook_event_type: dbEvent.extra_data?.hook_event_type || 'Unknown',
    payload: dbEvent.extra_data?.payload || {},
    chat: dbEvent.extra_data?.chat,
    summary: dbEvent.extra_data?.summary,
    timestamp: new Date(dbEvent.timestamp).getTime()
  }
}
```

### Phase 3: Hook Script Integration

1. **Update Hook Scripts** to use logger_agent API:
```python
# Update send_event.py to use logger_agent endpoint
def send_event_to_server(event_data, server_url='http://localhost:8000/events'):
    # Same implementation, just different default URL
```

2. **Create Logger Agent Hook Configuration** (`.claude/settings.json`):
```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": ".*",
      "hooks": [
        {
          "type": "command",
          "command": "uv run .claude/hooks/send_event.py --source-app logger-agent --event-type PreToolUse"
        }
      ]
    }],
    "PostToolUse": [{
      "matcher": ".*", 
      "hooks": [
        {
          "type": "command",
          "command": "uv run .claude/hooks/send_event.py --source-app logger-agent --event-type PostToolUse --add-chat"
        }
      ]
    }]
  }
}
```

### Phase 4: Additional Features

1. **Enhanced Search Using ArangoDB**:
   - Leverage ArangoSearch for full-text search
   - Use graph traversals for execution flow visualization
   - Implement semantic search using embeddings

2. **Real-time Analytics**:
   - Use AQL for complex aggregations
   - Create live dashboards with execution metrics
   - Build agent performance tracking

3. **Integration with Existing Logger Agent Features**:
   - Link dashboard events to agent learnings
   - Show relationship graphs between log events
   - Display memory agent insights

## Directory Structure

```
logger_agent/
├── dashboard/                      # Vue 3 frontend
│   ├── src/
│   │   ├── App.vue
│   │   ├── components/
│   │   ├── composables/
│   │   └── utils/
│   ├── package.json
│   └── vite.config.ts
├── src/
│   ├── api/                       # New API layer
│   │   ├── __init__.py
│   │   ├── dashboard_server.py    # FastAPI server
│   │   ├── websocket_manager.py   # WebSocket handling
│   │   └── event_transformer.py   # Data transformation
│   └── ... (existing files)
├── .claude/                       # Claude Code hooks
│   ├── hooks/
│   │   └── send_event.py
│   └── settings.json
└── scripts/
    ├── start_dashboard.sh         # Launch dashboard
    └── setup_dashboard.sh         # Initial setup
```

## Benefits of This Integration

1. **Leverages Existing Infrastructure**: Uses logger_agent's ArangoDB setup
2. **Enhanced Capabilities**: 
   - Graph-based execution flow visualization
   - Semantic search using embeddings
   - Integration with agent learnings and memory
3. **Scalability**: ArangoDB handles high-volume log ingestion better
4. **Unified System**: Single database for all agent data

## Next Steps

1. Implement the FastAPI server with WebSocket support
2. Adapt the Vue frontend to work with the new API
3. Test integration with sample Claude Code hook events
4. Add ArangoDB-specific features (graph visualization, semantic search)
5. Create deployment scripts and documentation

## Technical Considerations

- **Performance**: ArangoDB's document store is well-suited for log data
- **Real-time**: WebSocket broadcasting ensures live updates
- **Filtering**: AQL provides powerful query capabilities
- **Scale**: Can handle multiple agents logging simultaneously
- **Integration**: Seamlessly works with existing logger_agent features