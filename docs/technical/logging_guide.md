# CC Executor Logging Guide

This guide consolidates all logging-related documentation for CC Executor, providing a comprehensive reference for debugging and monitoring.

## Overview

CC Executor uses a multi-layered logging strategy to capture different aspects of system operation:
- Real-time console output for immediate feedback
- Structured application logs for detailed debugging
- Test artifacts for verification
- Transcript logs to overcome Claude UI truncation
- Claude's native transcripts as the final record

## Log Locations

### 1. Console Output (Interactive Development)
- **What:** Real-time `print()` statements and basic Loguru output (INFO level and above)
- **Where:** The terminal running the server
- **Use Case:** Immediate feedback during active development

### 2. Application Logs (Deep Debugging)
- **What:** Detailed, structured logs from the Loguru library (DEBUG, INFO, WARNING, ERROR)
- **Where:** Persisted in the `logs/` directory with rotation
  - File pattern: `websocket_handler_YYYY-MM-DD_HH-MM-SS.log`
  - Rotation: New file every 10MB
  - Retention: Last 5 files kept
- **Use Case:** Primary source for debugging server-side application logic, especially for post-mortem analysis

### 3. Test Artifacts (Verification)
- **What:** Full, raw stdout/stderr from specific test runs
- **Where:** Saved in the `test_outputs/` directory
  - File pattern: `claude_test_<test_type>_YYYYMMDD_HHMMSS.txt`
- **Use Case:** Verifying exact output for regression testing and debugging truncation issues

### 4. Full Transcript Logs (No Truncation)
- **What:** Complete, unabridged command outputs captured before Claude UI truncation
- **Where:** `logs/transcripts/transcript_YYYYMMDD_HHMMSS.jsonl`
- **Format:** JSONL with command details, full output, checksums, and execution metadata
- **Use Case:** Solving the Claude `[truncated]` limitation for outputs >10KB

The transcript logging captures:
- Command and working directory
- Full stdout/stderr output (no truncation)
- Line numbers and byte counts
- MD5 checksums for verification
- Execution timing and exit codes

### 5. Claude Transcripts (Final Result)
- **What:** Official, structured `.jsonl` output generated by the `claude` tool itself
- **Where:** `~/.claude/projects/-home-graham-workspace-experiments-cc-executor/*.jsonl`
- **Use Case:** The final, persistent result of successful `claude` runs - the "database" of AI work

## Log Levels

- **DEBUG**: Detailed execution flow, variable values, function entries/exits
- **INFO**: Normal operation events (process started, completed, etc.)
- **WARNING**: Timeouts, retries, degraded functionality
- **ERROR**: Exceptions, failures, critical issues with full stack traces

## Configuration

### Environment Variables
```bash
# Set log level for console output
export LOG_LEVEL=DEBUG

# Configure log file retention
export LOG_FILE_RETENTION=5

# Set maximum log file size before rotation
export LOG_FILE_MAX_SIZE=10485760  # 10MB
```

### Configuration Files
- `src/cc_executor/core/websocket_handler.py` - Main logging setup
- `src/cc_executor/core/config.py` - Log level environment variables

## Transcript Logging Usage

### Basic Usage
```python
from src.cc_executor.utils.process_executor import execute_with_transcript_logging

# Execute with automatic transcript logging
exit_code, exec_id = await execute_with_transcript_logging(
    command='claude -p "Write a 5000 word story"',
    callback=your_callback_function,
    cwd='/path/to/project',
    timeout=600
)

print(f"Execution ID: {exec_id}")
print(f"Full transcript at: logs/transcripts/transcript_*.jsonl")
```

### Searching Transcripts
```python
from src.cc_executor.utils.transcript_logger import get_transcript_logger

logger = get_transcript_logger()

# Search for specific content
results = logger.search_transcript("The Ghost in the Repository", exec_id)

# Get execution summary
summary = logger.get_execution_summary(exec_id)
print(f"Total bytes: {summary['total_bytes']}")
print(f"Duration: {summary['duration']}s")
```

### Reconstructing Full Output
```python
# Reconstruct complete output from transcript
full_output = []
with open(logger.log_file, 'r') as f:
    for line in f:
        entry = json.loads(line)
        if entry.get('exec_id') == exec_id and entry['type'] == 'output':
            full_output.append(entry['data'])

complete_text = ''.join(full_output)
```

## Debugging Tips

### Finding Recent Logs
```bash
# Most recent application log
ls -t logs/*.log | head -1

# Most recent test output
ls -t test_outputs/*.txt | head -1

# Most recent transcript log
ls -t logs/transcripts/*.jsonl | head -1

# Search Claude transcripts for specific output
rg "your_search_term" ~/.claude/projects/-home-graham-workspace-experiments-cc-executor/*.jsonl

# Search full transcript logs for specific content
rg "your_search_term" logs/transcripts/*.jsonl
```

### Common Log Patterns

#### Successful Execution
```
Starting stdout streaming with no timeout, buffer_size=1,048,576
[CLIENT] Connected!
[CLIENT] Running LARGE test - 5000 word story (3-5 minutes)
stdout: Large line #1 - 35,869 bytes
stdout progress: 100 lines, 102,400 bytes in 10.2s (10.0 KB/s)
[LARGE OUTPUT] stdout sending 35,869 chars
stdout completed: 156 lines, 38,203 bytes in 266.1s
[PROCESS COMPLETED] PID: 12345, Exit code: 0, Status: completed
```

#### Problem Indicators
```
Line truncated at buffer boundary (1,048,576 bytes)  # Buffer too small
Stream ended while reading large line                # Incomplete data
Error streaming stdout after 10.1s: [error]          # Stream failure
[PROCESS COMPLETED] Exit code: 1, Status: failed    # Command failed
Starting stdout streaming                            # Process started but hung
```

### Common Issues and Where to Look

1. **Process Hanging**: 
   - Check application logs for timeout warnings
   - Look for "Starting stdout streaming" without subsequent output
   - Verify stdin is closed properly in process_manager.py

2. **Truncated Output**: 
   - Check test_outputs for full content
   - Look for "Line truncated at buffer boundary" in logs
   - Check transcript logs for complete output

3. **MCP Tool Issues**: 
   - Look for initialization errors in DEBUG logs
   - Check for tool registration messages

4. **WebSocket Connection Issues**:
   - Look for ping/pong timeout messages
   - Check for "WebSocket connection closed" errors

## Important Notes

1. **Claude Transcript Truncation**: The Claude UI may show `[truncated]` for large outputs, but full content is preserved in both test_outputs and transcript logs

2. **Async Logging**: File logging is non-blocking (enqueued) to prevent I/O from slowing down the WebSocket handler

3. **Backtrace**: ERROR logs include full stack traces with variable values for debugging

4. **Transcript Log Growth**: Transcript logs grow quickly - implement rotation if needed:
   ```python
   # Example rotation setup
   from loguru import logger
   logger.add(
       "logs/transcripts/transcript_{time}.jsonl",
       rotation="100 MB",
       retention="7 days"
   )
   ```

5. **Unique Execution IDs**: Each command execution gets a unique ID for tracking across all log types

## Performance Considerations

- **Console Logging**: Minimal overhead, suitable for production
- **File Logging**: Async writes, negligible impact on performance
- **Transcript Logging**: Can grow large with verbose commands; monitor disk usage
- **Debug Logging**: Significantly more verbose; use only during active debugging

## Integration with Monitoring

CC Executor logs can be integrated with monitoring systems:

```python
# Example: Send ERROR logs to external monitoring
@logger.catch
async def monitored_function():
    try:
        await risky_operation()
    except Exception as e:
        # Log locally
        logger.error(f"Operation failed: {e}")
        # Send to monitoring
        await send_to_monitoring_service({
            "error": str(e),
            "traceback": traceback.format_exc(),
            "timestamp": datetime.now().isoformat()
        })
        raise
```

## Best Practices

1. **Use Structured Logging**:
   ```python
   logger.info("Process completed", 
               pid=process.pid, 
               exit_code=exit_code, 
               duration=duration)
   ```

2. **Include Context**:
   ```python
   logger.bind(session_id=session_id, command=command).info("Starting execution")
   ```

3. **Log at Appropriate Levels**:
   - DEBUG: Function entry/exit, variable values
   - INFO: Major operations, state changes
   - WARNING: Recoverable issues, degraded performance
   - ERROR: Failures requiring attention

4. **Rotate Logs Regularly**: Prevent disk space issues with proper rotation policies

5. **Monitor Log Growth**: Set up alerts for rapid log growth indicating issues

Last updated: 2025-07-02