# CC-Executor Logging Guide

This project uses a multi-layered logging strategy. Understanding where to look is key to debugging.

## Log Locations

### 1. Console Output (for Interactive Dev)
- **What:** Real-time `print()` statements and basic Loguru output (INFO level and above)
- **Where:** The terminal running the server
- **Use Case:** Immediate feedback during active development

### 2. Application Logs (for Deep Debugging)
- **What:** Detailed, structured logs from the Loguru library (DEBUG, INFO, WARNING, ERROR)
- **Where:** Persisted in the `logs/` directory with rotation
  - File pattern: `websocket_handler_YYYY-MM-DD_HH-MM-SS.log`
  - Rotation: New file every 10MB
  - Retention: Last 5 files kept
- **Use Case:** The primary source for debugging server-side application logic, especially for post-mortem analysis after a crash

### 3. Test Artifacts (for Verification)
- **What:** The full, raw stdout/stderr from specific test runs
- **Where:** Saved in the `test_outputs/` directory
  - File pattern: `claude_test_<test_type>_YYYYMMDD_HHMMSS.txt`
- **Use Case:** Verifying the exact output of a command for regression testing and debugging truncation issues

### 4. Claude Transcripts (The Final Result)
- **What:** The official, structured `.jsonl` output generated by the `claude` tool itself
- **Where:** `~/.claude/projects/-home-graham-workspace-experiments-cc-executor/*.jsonl`
- **Use Case:** This is the final, persistent result of a successful `claude` run. This is the "database" of the AI's work

### 5. Full Transcript Logs (No Truncation)
- **What:** Complete, unabridged command outputs captured before Claude UI truncation
- **Where:** `logs/transcripts/transcript_YYYYMMDD_HHMMSS.jsonl`
- **Format:** JSONL with command details, full output, checksums, and execution metadata
- **Use Case:** Solving the Claude `[truncated]` limitation for outputs >10KB, enabling reliable hallucination detection and debugging

The transcript logging solution captures:
- Command and working directory
- Full stdout/stderr output (no truncation)
- Line numbers and byte counts
- MD5 checksums for verification
- Execution timing and exit codes

## Debugging Tips

### Finding Recent Logs
```bash
# Most recent application log
ls -t logs/*.log | head -1

# Most recent test output
ls -t test_outputs/*.txt | head -1

# Most recent transcript log
ls -t logs/transcripts/*.jsonl | head -1

# Search Claude transcripts for specific output
rg "your_search_term" ~/.claude/projects/-home-graham-workspace-experiments-cc-executor/*.jsonl

# Search full transcript logs for specific content
rg "your_search_term" logs/transcripts/*.jsonl
```

### Common Issues

1. **Process Hanging**: Check application logs for timeout warnings
2. **Truncated Output**: Check test_outputs for full content - Claude UI may truncate large outputs
3. **MCP Tool Issues**: Look for initialization errors in DEBUG logs

## Log Levels

- **DEBUG**: Detailed execution flow, variable values, function entries/exits
- **INFO**: Normal operation events (process started, completed, etc.)
- **WARNING**: Timeouts, retries, degraded functionality
- **ERROR**: Exceptions, failures, critical issues

## Configuration

Logging is configured in:
- `src/cc_executor/core/websocket_handler.py` - Main logging setup
- `src/cc_executor/core/config.py` - Log level environment variables

To change log levels:
```bash
export LOG_LEVEL=DEBUG  # For console output
```

## Transcript Logging Usage

### Basic Usage

```python
from src.cc_executor.utils.process_executor import execute_with_transcript_logging

# Execute with automatic transcript logging
exit_code, exec_id = await execute_with_transcript_logging(
    command='claude -p "Write a 5000 word story"',
    callback=your_callback_function,
    cwd='/path/to/project',
    timeout=600
)

print(f"Execution ID: {exec_id}")
print(f"Full transcript at: logs/transcripts/transcript_*.jsonl")
```

### Searching Transcripts

```python
from src.cc_executor.utils.transcript_logger import get_transcript_logger

logger = get_transcript_logger()

# Search for specific content
results = logger.search_transcript("The Ghost in the Repository", exec_id)

# Get execution summary
summary = logger.get_execution_summary(exec_id)
print(f"Total bytes: {summary['total_bytes']}")
print(f"Duration: {summary['duration']}s")
```

### Reconstructing Full Output

```python
# Reconstruct complete output from transcript
full_output = []
with open(logger.log_file, 'r') as f:
    for line in f:
        entry = json.loads(line)
        if entry.get('exec_id') == exec_id and entry['type'] == 'output':
            full_output.append(entry['data'])

complete_text = ''.join(full_output)
```

## Important Notes

1. **Claude Transcript Truncation**: The Claude UI may show `[truncated]` for large outputs, but the full content is preserved in both test_outputs and transcript logs
2. **Async Logging**: File logging is non-blocking (enqueued) to prevent I/O from slowing down the WebSocket handler
3. **Backtrace**: ERROR logs include full stack traces with variable values for debugging
4. **Transcript Log Growth**: Transcript logs grow quickly - implement rotation if needed
5. **Unique Execution IDs**: Each command execution gets a unique ID for tracking across all log types