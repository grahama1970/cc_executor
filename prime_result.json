{
  "code": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef generate_primes(limit):\n    \"\"\"Generate all prime numbers up to a given limit.\"\"\"\n    primes = []\n    for num in range(2, limit + 1):\n        if is_prime(num):\n            primes.append(num)\n    return primes\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate primes using the Sieve of Eratosthenes algorithm.\"\"\"\n    if limit < 2:\n        return []\n    \n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, limit + 1, i):\n                sieve[j] = False\n    \n    return [i for i in range(2, limit + 1) if sieve[i]]",
  "explanation": "This module provides three functions for working with prime numbers:\n\n1. **is_prime(n)**: Checks if a single number is prime using trial division. It's optimized by only checking odd divisors up to the square root of n.\n\n2. **generate_primes(limit)**: Generates all prime numbers up to a given limit using the is_prime function. This has O(nâˆšn) time complexity.\n\n3. **sieve_of_eratosthenes(limit)**: A more efficient algorithm for generating all primes up to a limit. It marks multiples of each prime as composite, achieving O(n log log n) time complexity.\n\nThe Sieve of Eratosthenes is preferred for generating many primes, while is_prime is useful for checking individual numbers."
}