{
  "review_id": "002_websocket_reliability",
  "component": "core_implementation",
  "focus": "websocket_reliability_remaining_issues",
  "date": "2025-06-25",
  "fixes": [
    {
      "id": 1,
      "severity": "critical",
      "category": "concurrency",
      "file": "implementation.py",
      "line": 337,
      "issue": "Race condition: session can be deleted between check and access",
      "fix": "Add session_lock = asyncio.Lock() at module level, use 'async with session_lock:' for all SESSIONS modifications",
      "test": "Send 100 concurrent execute requests, verify no KeyError exceptions"
    },
    {
      "id": 2,
      "severity": "critical",
      "category": "resource_limits",
      "file": "implementation.py",
      "line": 311,
      "issue": "No session limit enforcement - memory exhaustion possible",
      "fix": "Before creating session: if len(SESSIONS) >= 100: await send_json_rpc_error(websocket, -32603, 'Session limit exceeded', None); return",
      "test": "Open 101 WebSocket connections, verify 101st is rejected"
    },
    {
      "id": 3,
      "severity": "critical",
      "category": "reliability",
      "file": "implementation.py",
      "line": 259,
      "issue": "No timeout on stream gathering - sessions hang forever on silent processes",
      "fix": "Replace gather with: await asyncio.wait_for(asyncio.gather(stdout_task, stderr_task, return_exceptions=True), timeout=300)",
      "test": "Execute 'python -c \"import time; time.sleep(3600)\"', verify timeout after 5 minutes"
    },
    {
      "id": 4,
      "severity": "major",
      "category": "data_integrity",
      "file": "implementation.py",
      "line": 194,
      "issue": "Lines at 8KB boundary are silently truncated",
      "fix": "After readline: if len(line) == 8192 and not line.endswith(b'\\n'): while (char := await stream.read(1)) and char != b'\\n': pass",
      "test": "Send line with exactly 8192 chars, verify complete line received"
    },
    {
      "id": 5,
      "severity": "major",
      "category": "memory_management",
      "file": "implementation.py",
      "line": 187,
      "issue": "No total memory limit across all output lines",
      "fix": "Add session['total_output_bytes'] tracking, drop lines if > 10MB total",
      "test": "Run 'while true; do echo \"data\"; done' for 60s, verify memory < 100MB"
    },
    {
      "id": 6,
      "severity": "minor",
      "category": "control_flow",
      "file": "implementation.py",
      "line": 382,
      "issue": "else block attached to try/except instead of if/elif chain",
      "fix": "Move 'Unknown control type' handling inside the try block after elif chain",
      "test": "Send control command with type='INVALID', verify 'Unknown control type' error"
    },
    {
      "id": 7,
      "severity": "major",
      "category": "cleanup",
      "file": "implementation.py",
      "line": 397,
      "issue": "Cancelled task not awaited - continues running",
      "fix": "After task.cancel(): try: await asyncio.wait_for(task, timeout=1.0) except: pass",
      "test": "Cancel long-running task, verify it actually stops"
    },
    {
      "id": 8,
      "severity": "minor",
      "category": "error_handling",
      "file": "implementation.py",
      "line": 269,
      "issue": "Re-raising CancelledError prevents cleanup completion",
      "fix": "Log the cancellation but don't re-raise in execute_command_task",
      "test": "Cancel execution during process run, verify full cleanup occurs"
    }
  ],
  "summary": {
    "previously_implemented": 4,
    "incorrectly_skipped": 5,
    "new_issues_found": 3,
    "total_remaining": 8,
    "critical_count": 3,
    "must_fix_for_reliability": ["session_locking", "session_limits", "stream_timeout", "partial_lines"]
  }
}