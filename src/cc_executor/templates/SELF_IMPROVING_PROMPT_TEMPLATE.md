# [Component Name] ‚Äî Self-Improving Prompt

<!-- 
IMPORTANT: This is the standard template for construction-focused prompts.
For execution-focused prompts (test runners), see PROMPT_SYSTEM_GUIDELINES.md 
for acceptable variants and deviation documentation requirements.
-->

## üìä TASK METRICS & HISTORY
<!-- This section is updated by the Implementer (Claude) after every run -->
- **Success/Failure Ratio**: 0:0 (Requires 10:1 to graduate)
- **Last Updated**: YYYY-MM-DD
- **Evolution History**:
  | Version | Change & Reason                                     | Result |
  | :------ | :---------------------------------------------------- | :----- |
  | v1      | Initial implementation generated from Project Blueprint. | TBD    |

---
## üèõÔ∏è ARCHITECT'S BRIEFING (Immutable)
<!-- Generated by the Orchestrator (Gemini) from the Project Blueprint. -->
<!-- Implementer (Claude): DO NOT EDIT THIS SECTION. Your work is below. -->

### 1. Purpose
[Auto-populated from Blueprint: Component Description]

### 2. Core Principles & Constraints
- [Auto-populated list of Global and Component-Specific Principles]

### 3. API Contract & Dependencies
- **This Service's API:**
  - `GET /health`: Returns `{"status": "ok"}` and checks dependency health.
  - `POST /tasks`: [e.g., Accepts `{"command": str, "args": list}`]
- **Dependencies (via Environment Variables):**
  - `[e.g., STATE_MANAGER_URL]`: URL for the State Manager service.

---
## ü§ñ IMPLEMENTER'S WORKSPACE (Claude's Section)
<!-- Implementer: You work exclusively here. Execute the plan step-by-step. -->
<!-- Modify ONLY the 'Implementation Code Block'. Do not touch any other part of this file. -->

### **Implementation Code Block**
<!-- This is the ONLY code you will modify. It will be saved as the final component file upon graduation. -->
```python
#!/usr/bin/env python3
# Start with the code for Step 1 here.
# This code will be incrementally built up as you complete each step.
import os
import uvicorn
from fastapi import FastAPI

app = FastAPI()

@app.get("/health")
async def health_check():
    return {"status": "ok"}

# The rest of the implementation will be added here in later steps.

if __name__ == "__main__":
    # This block will be filled out in a later step.
    print("Self-verification not yet implemented.")

```

### **Task Execution Plan & Log**
<!-- Execute each step IN ORDER. Do not proceed until the current step's verification passes. -->
<!-- The Orchestrator will save the code block above to a temporary file and run the verification command. -->

#### **Step 1: Basic Health Check**
*   **Goal:** Create a running FastAPI server with a functioning `/health` endpoint.
*   **Action:** Write the initial FastAPI code in the block above with a single `/health` route.
*   **Verification Command:** `python3 -c "import requests; assert requests.get('http://localhost:8000/health').json() == {'status': 'ok'}"`
*   **Expected Output:** The command should exit with status code 0 and produce no output.

**--- EXECUTION LOG (Step 1) ---**
```text
Implementer: Paste the full, unedited output of the Verification Command here.
```
---
#### **Step 2: [Auto-Generated Step Name]**
*   **Goal:** [Auto-Generated Goal]
*   **Action:** [Auto-Generated Action]
*   **Verification Command:** `[Auto-Generated Verification Command]`
*   **Expected Output:** [Auto-Generated Expected Output]

**--- EXECUTION LOG (Step 2) ---**
```text
Implementer: Paste the full, unedited output of the Verification Command here.
```
---
<!-- (More steps follow as defined by the Orchestrator) -->

---
## üéì GRADUATION & VERIFICATION (Automated by Orchestrator)
<!-- This section informs the final validation stages run by the Orchestrator. -->

### 1. Component Integration Test
*   **Test Script Path:** `[Auto-populated from Blueprint: e.g., tests/integration/test_state_manager.py]`
*   **Execution:** This test will be run against the graduated code (from the `Implementation Code Block`) after all internal steps above have passed.

### 2. Self-Verification (`if __name__ == "__main__"`)
*   **Task:** The final step in the `Task Execution Plan` will be to implement this block.
*   **PREDICTION (from Architect):**
    *   [Auto-populated from Blueprint: A clear, high-level description of what the self-verification should do and what its output structure must be.]
    *   *Example:* "The block should create a new task via an HTTP POST and then immediately query its status, printing the final state. The output must be a JSON object containing a `task_id` and a `status` of 'RUNNING'."
*   **Assertion:** The `if __name__ == "__main__"` block in the final code must contain `assert` statements that programmatically verify the prediction.

---
## üîç DEBUGGING BEST PRACTICES (Mandatory for All Prompts)
<!-- This section contains critical debugging patterns that MUST be followed -->

### Research Pattern (ALWAYS use both tools concurrently):
When encountering technical issues or unexpected behavior:
1. **Use perplexity-ask MCP tool** for real-time information and known bugs
2. **Use gemini CLI (ask-gemini-cli.md)** for best practices and in-depth analysis
3. Execute both queries concurrently using the Task tool for efficiency

### Subprocess Management Pattern (CRITICAL for CLI tools):
```python
# CORRECT pattern for Node.js based CLIs (Claude, npm, etc):
import os, signal, subprocess, asyncio

# SYNCHRONOUS VERSION (prone to deadlock with large outputs):
proc = subprocess.Popen(
    cmd,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    preexec_fn=os.setsid  # Create new process group
)

try:
    stdout, stderr = proc.communicate(timeout=60)
except subprocess.TimeoutExpired:
    # Kill entire process group to prevent zombies
    pgid = os.getpgid(proc.pid)
    os.killpg(pgid, signal.SIGTERM)
    time.sleep(0.5)
    os.killpg(pgid, signal.SIGKILL)
    proc.wait()

# ASYNC VERSION (prevents pipe buffer deadlock):
async def _drain_stream(stream, prefix):
    """Continuously drain a stream to prevent deadlock."""
    while True:
        line = await stream.readline()
        if not line:
            break
        print(f"[{prefix}] {line.decode().strip()}", flush=True)

proc = await asyncio.create_subprocess_exec(
    *cmd,
    stdout=asyncio.subprocess.PIPE,
    stderr=asyncio.subprocess.PIPE,
    preexec_fn=os.setsid
)

# CRITICAL: Create tasks to drain streams IMMEDIATELY
# This prevents pipe buffer from filling up and causing deadlock
asyncio.create_task(_drain_stream(proc.stdout, 'STDOUT'))
asyncio.create_task(_drain_stream(proc.stderr, 'STDERR'))

# Now safe to wait for completion
exit_code = await proc.wait()
```

### Known Issues:
- **CRITICAL: Claude CLI uses -p NOT --print!** The --print flag does not exist and causes 20+ second hangs!
  - ‚úÖ CORRECT: `claude -p "prompt text"`
  - ‚ùå WRONG: `claude --print "prompt text"`
- Claude CLI bug #1285: Hangs with `-p` flag in sequential runs
- Node.js CLIs spawn child processes that must be killed as a group
- **CRITICAL: Subprocess pipe buffer deadlock** - If stdout/stderr pipes fill up (typically 64KB) and aren't being actively read, the subprocess will block forever waiting for buffer space. This is an OS-level constraint. Always drain streams actively or redirect to files.

---
## üî¨ DIAGNOSTICS & RECOVERY (Architect-Led)
<!-- This section is added by the Orchestrator ONLY if the Component Integration Test fails. -->
<!-- Example block that would be added on failure:
### Failure Report (YYYY-MM-DD)
- **Failed Version:** v3
- **Test That Failed:** `tests/integration/test_process_controller.py`
- **Failure Log (`stderr`):**
  ```text
  AssertionError: Expected status to be 'RUNNING', but was 'PENDING'.
  ```
### Architect's Recovery Plan for Next Version (v4)
- **Root Cause:** The `/tasks` endpoint returns a response before the process is confirmed to be running by the OS.
- **Recovery Plan:** Modify the `/tasks` endpoint to wait for a successful process creation signal before returning the HTTP response. Add a new verification step to check for this race condition.
-->